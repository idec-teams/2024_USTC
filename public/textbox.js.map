{"version":3,"file":"textbox.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;;;;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC9jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AACA;AACA;;;;;;;;;;;;;;ACFA;AACA;AACA;;;;;;;;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjCA;AACA;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;;;;;;;;;;;ACFA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://2024_ustc/./node_modules/ef-core/src/ef-core.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/binding.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/creator.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/element-creator.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/map-attrs.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/render-queue.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/renderer.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/resolver.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/array-helper.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/debug.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/dom-arr-helper.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/dom-helper.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/event-helper.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/fast-instance-of.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/global-shared.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/is-browser.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/isnan.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/namespaces.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/noop.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/polyfills.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/scoped-component.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/string-ops.js","webpack://2024_ustc/./node_modules/ef-core/src/lib/utils/type-of.js","webpack://2024_ustc/./node_modules/ef-core/src/mount-options.js","webpack://2024_ustc/./src/textbox.eft","webpack://2024_ustc/./src/textbox.css?c39c","webpack://2024_ustc/webpack/bootstrap","webpack://2024_ustc/webpack/runtime/define property getters","webpack://2024_ustc/webpack/runtime/hasOwnProperty shorthand","webpack://2024_ustc/./src/textbox.js"],"sourcesContent":["// Import everything\nimport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent} from './lib/renderer.js'\nimport {applyMountPoint} from './lib/creator.js'\nimport mountOptions from './mount-options.js'\nimport mapAttrs from './lib/map-attrs.js'\nimport {onNextRender, inform, exec, bundle, isPaused} from './lib/render-queue.js'\nimport dbg from './lib/utils/debug.js'\nimport typeOf from './lib/utils/type-of.js'\nimport scoped from './lib/utils/scoped-component.js'\nimport {setDOMImpl} from './lib/utils/dom-helper.js'\nimport {declareNamespace} from './lib/utils/namespaces.js'\n\nconst registerNS = (attrs, component) => {\n\tfor (let i in attrs) {\n\t\tif (i.indexOf('xmlns:') === 0) {\n\t\t\tconst [, prefix] = i.split(':')\n\t\t\tcomponent.__local_namespaces[prefix] = attrs[i]\n\t\t}\n\t}\n}\n\n// Intialize components\nconst initComponent = (component, node) => {\n\tconst nodeType = typeOf(node)\n\tswitch (nodeType) {\n\t\tcase 'array': {\n\t\t\tconst [info, ...childNodes] = node\n\t\t\tif (typeOf(info) === 'object') {\n\t\t\t\tcomponent.__used_tags[info.t] = true\n\t\t\t\tif (info.a) registerNS(info.a, component)\n\t\t\t\tfor (let i of childNodes) initComponent(component, i)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\tcase 'object': {\n\t\t\tif (node.t > 1) throw new TypeError(`[EF] Not a standard ef.js AST: Unknown mount point type '${node.t}'`)\n\t\t\tapplyMountPoint(node.t, node.n, component)\n\t\t\tbreak\n\t\t}\n\t\tcase 'string': {\n\t\t\tbreak\n\t\t}\n\t\tdefault: {\n\t\t\tthrow new TypeError(`[EF] Not a standard ef.js AST: Unknown node type '${nodeType}'`)\n\t\t}\n\t}\n}\n\n/**\n * @typedef {import('./mount-options.js').EFMountOption} EFMountOption\n * @typedef {import('./mount-options.js').EFMountConfig} EFMountConfig\n * @typedef {import('./lib/renderer.js').EFAST} EFAST\n * @typedef {import('./lib/renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('./lib/renderer.js').EFEventHandlerArg} EFEventHandlerArg\n * @typedef {import('./lib/renderer.js').EFEventHandlerMethod} EFEventHandlerMethod\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerArg} EFSubscriberHandlerArg\n * @typedef {import('./lib/renderer.js').EFSubscriberHandlerMethod} EFSubscriberHandlerMethod\n * @typedef {import('./lib/renderer.js').EFTemplateScope} EFTemplateScope\n * @typedef {import('./lib/renderer.js').Fragment} Fragment\n * @typedef {import('./lib/renderer.js').EFNodeWrapper} EFNodeWrapper\n * @typedef {import('./lib/renderer.js').EFTextFragment} EFTextFragment\n * @typedef {import('./lib/utils/event-helper.js').EFEventOptions} EFEventOptions\n */\n\n// eslint-disable-next-line valid-jsdoc\n/**\n * Create a brand new component class for the new component\n * @param {EFAST} ast - AST for the component\n * @param {string=} name - Name of the component\n */\nconst create = (ast, name) => {\n\n\t/**\n\t * The very basic component which users can use\n\t * @class EFComponent\n\t * @param {Object=} initState - Initial state for the component to create with\n\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t */\n\tconst EFComponent = class extends EFBaseComponent {\n\n\t\t/**\n\t\t * Create an EFComponent with initial state\n\t\t * @param {Object=} initState - Initial state for the component to create with\n\t\t * @param {EFTemplateScope=} scope - Scope for the component to render template with\n\t\t */\n\t\tconstructor(initState, scope) {\n\t\t\tinform()\n\t\t\tsuper(ast, scope)\n\t\t\tif (initState) this.$update(initState)\n\t\t\texec()\n\t\t}\n\t}\n\n\tif (name) {\n\t\tObject.defineProperty(EFComponent, 'name', {value: name})\n\t}\n\n\t// Workaround for a bug of buble\n\t// https://github.com/bublejs/buble/issues/197\n\tObject.defineProperty(EFComponent.prototype, 'constructor', {enumerable: false})\n\n\tObject.defineProperty(EFComponent, '__local_namespaces', {enumerable: false, value: {}})\n\tObject.defineProperty(EFComponent, '__used_tags', {enumerable: false, value: {}})\n\tObject.defineProperty(EFComponent, '__component_ast', {enumerable: false, value: ast})\n\n\tinitComponent(EFComponent, ast)\n\treturn EFComponent\n}\n\nlet coreVersion = '0.17.5'\n\nif (process.env.NODE_ENV !== 'production') {\n\tcoreVersion = `${coreVersion}+debug`\n\n\tdbg.info(`ef-core v${coreVersion} initialized!`)\n\n\tif (typeof globalThis !== 'undefined') {\n\t\tif (!globalThis.devtoolsFormatters) globalThis.devtoolsFormatters = []\n\n\t\tconst shallowCloneObj = (obj, deletes) => {\n\t\t\tconst cloned = Object.create(null)\n\t\t\tconst descriptors = Object.getOwnPropertyDescriptors(obj)\n\t\t\tif (deletes) {\n\t\t\t\tfor (let i of deletes) {\n\t\t\t\t\tdelete descriptors[i]\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.defineProperties(cloned, descriptors)\n\t\t\treturn cloned\n\t\t}\n\n\t\tconst formatter = {\n\t\t\theader(obj, config) {\n\t\t\t\tif (config && config.__raw) return null\n\t\t\t\tif (obj instanceof EFBaseComponent) return ['div', {style: 'font-weight: bold; color: #5ccccc'}, `>${obj.constructor.name || '[Anonymous]'}`]\n\t\t\t\treturn null\n\t\t\t},\n\t\t\thasBody() {\n\t\t\t\treturn true\n\t\t\t},\n\t\t\tbody(obj) {\n\t\t\t\tconst mountPoints = Object.create(null)\n\t\t\t\tfor (let i in obj.$ctx.children) {\n\t\t\t\t\tmountPoints[i] = obj.$ctx.children[i].node\n\t\t\t\t}\n\n\t\t\t\tconst elements = [\n\t\t\t\t\t['div', {style: 'color: #4bcb5b'}, '$data:           ', ['object', {object: Object.assign(Object.create(null), obj.$ctx.data)}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b'}, '$refs:           ', ['object', {object: shallowCloneObj(obj.$ctx.refs)}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b'}, '$methods:        ', ['object', {object: shallowCloneObj(obj.$ctx.methods)}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b'}, '[[mountpoints]]: ', ['object', {object: mountPoints}]],\n\t\t\t\t\t['div', {style: 'color: #cc22bb'}, '[[props]]:       ', ['object', {object: shallowCloneObj(obj, ['$ctx'])}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b88'}, '[[element]]:     ', ['object', {object: obj.$ctx.nodeInfo.element}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b88'}, '[[parent]]:      ', ['object', {object: obj.$ctx.nodeInfo.parent}]],\n\t\t\t\t\t['div', {style: 'color: #4bcb5b88'}, '[[slot]]:        ', ['object', {object: obj.$ctx.nodeInfo.key}]]\n\t\t\t\t]\n\t\t\t\treturn ['div', {}, ...elements]\n\t\t\t}\n\t\t}\n\n\t\tglobalThis.devtoolsFormatters.push(formatter)\n\t}\n}\n\nexport {\n\tcreate,\n\tmapAttrs,\n\tEFBaseComponent,\n\tEFNodeWrapper,\n\tEFTextFragment,\n\tFragment,\n\ttoEFComponent,\n\tscoped,\n\tonNextRender,\n\tinform,\n\texec,\n\tbundle,\n\tisPaused,\n\tmountOptions,\n\tsetDOMImpl,\n\tdeclareNamespace,\n\tcoreVersion as version\n}\n","import {resolve} from './resolver.js'\nimport {inform, exec, queue} from './render-queue.js'\nimport ARR from './utils/array-helper.js'\nimport isnan from './utils/isnan.js'\nimport dbg from './utils/debug.js'\n\nconst initDataNode = (ctx, {parentNode, dataNode, handlerNode, subscriberNode, _key}) => {\n\tconst { state } = ctx\n\n\tconst applyQueue = () => queue(...handlerNode)\n\tlet updateInProgress = false\n\n\tObject.defineProperty(parentNode, _key, {\n\t\tget() {\n\t\t\treturn dataNode[_key]\n\t\t},\n\t\tset(value) {\n\t\t\tconst oldValue = dataNode[_key]\n\t\t\t// Comparing NaN is like eating a cake and suddenly encounter a grain of sand\n\t\t\tif (updateInProgress || oldValue === value || (isnan(oldValue) && isnan(value))) return\n\n\t\t\tupdateInProgress = true\n\n\t\t\tdataNode[_key] = value\n\n\t\t\tinform()\n\n\t\t\tqueue(applyQueue)\n\n\t\t\tif (subscriberNode.length > 0) {\n\t\t\t\ttry {\n\t\t\t\t\tfor (const subscriber of subscriberNode) subscriber({state, value, oldValue})\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdbg.error('Error caught when executing subscribers:\\n', e)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texec()\n\n\t\t\tupdateInProgress = false\n\t\t},\n\t\tenumerable: true\n\t})\n\n\t// Handle class data\n\tqueue(applyQueue)\n}\n\nconst initBinding = (ctx, {bind}) => {\n\tconst _path = ARR.copy(bind[0])\n\tconst _key = _path.pop()\n\n\tconst {data, handlers, subscribers, innerData} = ctx\n\n\tconst {parentNode, handlerNode, subscriberNode, dataNode} = resolve({\n\t\t_path,\n\t\t_key,\n\t\tdata,\n\t\thandlers,\n\t\tsubscribers,\n\t\tinnerData\n\t})\n\n\t// Initlize data binding node if not initialized\n\tconst keyStatus = Object.getOwnPropertyDescriptor(parentNode, _key)\n\tif (!keyStatus || !(keyStatus.get || keyStatus.set)) initDataNode(ctx, {parentNode, dataNode, handlerNode, subscriberNode, _key})\n\t// Update default value\n\t// bind[1] is the default value for this node\n\t// Only apply default value when class def doesn't exist\n\tif (bind.length > 1 && typeof dataNode[_key] === 'undefined') parentNode[_key] = bind[1]\n\n\treturn {dataNode, parentNode, handlerNode, subscriberNode, _key}\n}\n\nexport default initBinding\n","import {createElement, typeValid} from './element-creator.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {DOM, EFMountPoint, useFragment} from './utils/dom-helper.js'\nimport {hasColon, splitByColon, isSVGEscape} from './utils/string-ops.js'\nimport {getNamespace} from './utils/namespaces.js'\nimport noop from './utils/noop.js'\nimport defineArr from './utils/dom-arr-helper.js'\nimport ARR from './utils/array-helper.js'\nimport typeOf from './utils/type-of.js'\nimport initBinding from './binding.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst svgNS = getNamespace('svg')\nconst mathNS = getNamespace('math')\nconst htmlNS = getNamespace('html')\n\nconst nullComponent = Object.create(null)\n\nconst checkDestroyed = (state) => {\n\tif (!state.$ctx) throw new Error('[EF] This component has been destroyed!')\n}\n\nconst bindTextNode = (ctx, node, apply) => {\n\t// Data binding text node\n\tconst textNode = DOM.document.createTextNode('')\n\tconst { dataNode, handlerNode, _key } = initBinding(ctx, {bind: node})\n\tconst handler = () => {\n\t\tconst value = dataNode[_key]\n\t\tif (typeof value === 'undefined') {\n\t\t\ttextNode.textContent = ''\n\t\t\treturn\n\t\t}\n\t\ttextNode.textContent = value\n\t}\n\thandlerNode.push(handler)\n\n\t// Append element to the component\n\tapply(textNode)\n}\n\nconst updateMountNode = (ctx, key, value) => {\n\tconst {children} = ctx\n\tconst child = children[key]\n\tconst {anchor, node} = child\n\tif (node === value) return\n\n\tvalue = shared.toEFComponent(value)\n\n\tinform()\n\t// Update component\n\tif (node) {\n\t\tif (value === nullComponent) value = null\n\t\telse node.$umount()\n\t}\n\t// Update stored value\n\tchild.node = value\n\tif (value) value.$mount({target: anchor, parent: ctx.state, option: mountOptions.AFTER, key})\n\texec()\n}\n\nconst updateMountList = (ctx, key, value) => {\n\tconst {children} = ctx\n\tconst {anchor, node} = children[key]\n\tif (ARR.equals(node, value)) return\n\tinform()\n\tif (node.length) node.clear()\n\tif (value) {\n\t\tvalue = ARR.copy(value)\n\t\tuseFragment((fragment, recycleFragment) => {\n\t\t\t// Update components\n\t\t\tfor (let item of value) DOM.append(fragment, shared.toEFComponent(item).$mount({parent: ctx.state, key}))\n\t\t\t// Update stored value\n\t\t\tARR.push(node, ...value)\n\t\t\t// Append to current component\n\t\t\tqueueDom(() => {\n\t\t\t\tDOM.after(anchor, fragment)\n\t\t\t\trecycleFragment()\n\t\t\t})\n\t\t})\n\t}\n\texec()\n}\n\nconst mountPointUpdaters = [\n\tupdateMountNode,\n\tupdateMountList\n]\n\nconst applyMountPoint = (type, key, tpl) => {\n\tconst updater = mountPointUpdaters[type]\n\tObject.defineProperty(tpl.prototype, key, {\n\t\tget() {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\treturn this.$ctx.children[key].node\n\t\t},\n\t\tset(value) {\n\t\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\t\tconst ctx = this.$ctx\n\t\t\tupdater(ctx, key, value)\n\t\t},\n\t\tenumerable: true\n\t})\n}\n\nconst bindMountNode = (ctx, key, anchor) => {\n\tconst { children } = ctx\n\tconst info = {anchor}\n\tchildren[key] = info\n\tanchor[EFMountPoint] = info\n}\n\n// eslint-disable-next-line max-params\nconst bindMountList = (ctx, key, anchor, aftAnchor) => {\n\tconst { children } = ctx\n\tchildren[key] = {\n\t\tnode: defineArr([], {ctx, key, anchor, aftAnchor}),\n\t\tanchor,\n\t\taftAnchor\n\t}\n\tanchor[EFMountPoint] = children[key]\n}\n\n// Walk through the AST to perform proper actions\nconst resolveAST = (ctx, {apply, node, nodeType, namespace, create}) => {\n\tif (DOM.isNodeInstance(node)) {\n\t\tapply(node)\n\t\treturn\n\t}\n\n\tswitch (nodeType) {\n\t\t// Static text node\n\t\tcase 'string': {\n\t\t\tapply(DOM.document.createTextNode(node))\n\t\t\tbreak\n\t\t}\n\t\t// Child element or a dynamic text node\n\t\tcase 'array': {\n\t\t\t// Recursive call for child element\n\t\t\tif (typeOf(node[0]) === 'object') apply(create(ctx, {node, namespace}))\n\t\t\t// Dynamic text node\n\t\t\telse bindTextNode(ctx, node, apply)\n\t\t\tbreak\n\t\t}\n\t\t// Mount points\n\t\tcase 'object': {\n\t\t\tif (process.env.NODE_ENV !== 'production') apply(DOM.document.createComment(`<MountPoint${node.t && ' type=\"list\" ' || ' '}name=\"${node.n}\">`))\n\t\t\tconst anchor = DOM.document.createTextNode('')\n\t\t\t// Append anchor\n\t\t\tapply(anchor)\n\t\t\t// Single node mount point\n\t\t\tif (node.t === 0) bindMountNode(ctx, node.n, anchor)\n\t\t\telse {\n\t\t\t\t// Multi node mount point\n\t\t\t\tconst aftAnchor = DOM.document.createTextNode('')\n\t\t\t\tapply(aftAnchor)\n\t\t\t\tbindMountList(ctx, node.n, anchor, aftAnchor)\n\t\t\t}\n\t\t\tif (process.env.NODE_ENV !== 'production') apply(DOM.document.createComment('</MountPoint>'))\n\t\t\tbreak\n\t\t}\n\t\tdefault:\n\t}\n}\n\n// Create elements based on description from AST\n/* eslint {\"complexity\": \"off\"} */\nconst create = (ctx, {node, namespace}) => {\n\tconst [info, ...childNodes] = node\n\tconst previousNamespace = namespace\n\n\tlet tagName = info.t\n\tlet isLocalPrefix = false\n\n\tconst scoped = ctx.scope[tagName]\n\n\tconst fragment = tagName === 0\n\tconst custom = Object.isPrototypeOf.call(shared.EFBaseComponent, scoped || tagName)\n\n\t// Check if element needs a namespace\n\tif (!fragment && !custom) {\n\t\tif (scoped) {\n\t\t\tif (typeof scoped === 'string') tagName = scoped\n\t\t\telse if (scoped.tag) {\n\t\t\t\ttagName = scoped.tag\n\t\t\t\tif (scoped.namespaceURI) namespace = scoped.namespaceURI\n\t\t\t}\n\t\t}\n\t\tif (hasColon(tagName)) {\n\t\t\tconst [prefix, unprefixedTagName] = splitByColon(tagName)\n\t\t\tconst localNamespaceDef = ctx.localNamespaces[prefix]\n\t\t\tif (localNamespaceDef) {\n\t\t\t\tnamespace = localNamespaceDef\n\t\t\t\tisLocalPrefix = true\n\t\t\t} else {\n\t\t\t\tnamespace = getNamespace(prefix)\n\t\t\t}\n\t\t\ttagName = unprefixedTagName\n\t\t} else if (info.a && info.a.xmlns && typeValid(info.a.xmlns)) {\n\t\t\tnamespace = info.a.xmlns\n\t\t} else if (!namespace) {\n\t\t\ttagName = tagName.toLowerCase()\n\t\t\tswitch (tagName) {\n\t\t\t\tcase 'svg': {\n\t\t\t\t\tnamespace = svgNS\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase 'math': {\n\t\t\t\t\tnamespace = mathNS\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t}\n\t\t}\n\t}\n\n\tif (namespace === htmlNS) namespace = ''\n\n\t// First create an element according to the description\n\tconst [element, type] = createElement(ctx, info, namespace, fragment, custom)\n\n\tlet apply = noop\n\n\tswitch (type) {\n\t\tcase 'string':\n\t\tcase 'object': {\n\t\t\tapply = (...args) => {\n\t\t\t\tDOM.append(element, ...args)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tcase 'function': {\n\t\t\tconst { children } = element.$ctx\n\t\t\tif (children.children) {\n\t\t\t\tconst anchor = children.children.anchor\n\t\t\t\tif (anchor) {\n\t\t\t\t\tapply = (...args) => {\n\t\t\t\t\t\tDOM.before(anchor, ...args)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (Array.isArray(element.children)) {\n\t\t\t\tapply = (...args) => {\n\t\t\t\t\telement.children.push(...args)\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tcase 'fragment': {\n\t\t\tapply = (...args) => {\n\t\t\t\telement.append(...args)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\n\t\tdefault:\n\t}\n\n\tif (fragment && process.env.NODE_ENV !== 'production') apply(DOM.document.createComment('<Fragment>'))\n\n\t// Leave SVG mode if tag is `foreignObject`\n\tif (namespace && namespace === svgNS && isSVGEscape(tagName)) namespace = ''\n\n\t// restore previous namespace if namespace is defined locally\n\tif (isLocalPrefix) namespace = previousNamespace\n\n\t// Append child nodes\n\tfor (let node of childNodes) {\n\t\tresolveAST(ctx, {apply, node, nodeType: typeOf(node), namespace, create})\n\t}\n\tif (fragment && process.env.NODE_ENV !== 'production') apply(DOM.document.createComment('</Fragment>'))\n\n\treturn element\n}\n\nexport {create, nullComponent, checkDestroyed, applyMountPoint}\n","import initBinding from './binding.js'\nimport {inform, exec} from './render-queue.js'\nimport {resolvePath} from './resolver.js'\nimport ARR from './utils/array-helper.js'\nimport {DOM, EFFragment} from './utils/dom-helper.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport {getNamespace} from './utils/namespaces.js'\nimport {hasColon, splitByColon} from './utils/string-ops.js'\n\nconst typeValid = obj => ['number', 'boolean', 'string'].indexOf(typeof obj) > -1\n\n// eslint-disable-next-line max-params\nconst createByTag = (tagType, tagName, tagContent, attrs, namespace) => {\n\tswitch (tagType) {\n\t\tcase 'string': {\n\t\t\tif (tagName === tagContent && attrs && attrs.is && typeof attrs.is === 'string') {\n\t\t\t\tconst { is } = attrs\n\t\t\t\tif (namespace) return DOM.document.createElementNS(namespace, tagContent, {is})\n\t\t\t\treturn DOM.document.createElement(tagContent, {is})\n\t\t\t}\n\n\t\t\t// Namespaced\n\t\t\tif (namespace) return DOM.document.createElementNS(namespace, tagContent)\n\t\t\t// Then basic HTMLElements\n\t\t\treturn DOM.document.createElement(tagContent)\n\t\t}\n\t\tcase 'function': {\n\t\t\t// Then custom component or class based custom component\n\t\t\treturn new tagContent()\n\t\t}\n\t\tdefault: {\n\t\t\t// Then overriden basic element\n\t\t\tif (tagContent.tag) tagName = tagContent.tag\n\n\t\t\tif (tagContent.is) {\n\t\t\t\tconst { is } = tagContent\n\t\t\t\tif (namespace) return DOM.document.createElementNS(namespace, tagName, {is})\n\t\t\t\treturn DOM.document.createElement(tagName, {is})\n\t\t\t}\n\n\t\t\tif (namespace) return DOM.document.createElementNS(namespace, tagName)\n\t\t\treturn DOM.document.createElement(tagName)\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line max-params\nconst getElement = (tagType, tagName, tagContent, attrs, ref, refs, namespace) => {\n\tconst element = createByTag(tagType, tagName, tagContent, attrs, namespace)\n\tif (ref) Object.defineProperty(refs, ref, {\n\t\tvalue: element,\n\t\tenumerable: true\n\t})\n\treturn element\n}\n\nconst getVal = (dataNode, key) => {\n\tconst data = dataNode[key]\n\tif (typeof data === 'undefined') return ''\n\treturn data\n}\n\nconst regTmpl = (ctx, val, handler) => {\n\tif (ARR.isArray(val)) {\n\t\tconst [strs, ...exprs] = val\n\n\t\tif (!strs) {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding(ctx, {bind: exprs[0]})\n\t\t\tconst _handler = () => handler(getVal(dataNode, _key))\n\t\t\thandlerNode.push(_handler)\n\n\t\t\treturn _handler\n\t\t}\n\n\t\tconst tmpl = new Array(strs.length + exprs.length)\n\t\tconst evalList = []\n\n\t\tfor (let i in strs) {\n\t\t\ttmpl[i * 2] = strs[i]\n\t\t}\n\n\t\tconst _handler = () => {\n\t\t\tfor (let i of evalList) i()\n\t\t\treturn handler(''.concat(...tmpl))\n\t\t}\n\n\t\tevalList.push(...exprs.map((item, index) => {\n\t\t\tconst {dataNode, handlerNode, _key} = initBinding(ctx, {bind: item})\n\t\t\thandlerNode.push(_handler)\n\n\t\t\tindex = index * 2 + 1\n\n\t\t\treturn () => {\n\t\t\t\ttmpl[index] = getVal(dataNode, _key)\n\t\t\t}\n\t\t}))\n\n\t\treturn _handler\n\t}\n\treturn () => val\n}\n\n// eslint-disable-next-line max-params\nconst applyEventListener = (element, custom, handler, {l, s, i, p, h, a, c, t, u, e, o, k}) => {\n\n\t/*\n\t *  l: listener                 : string\n\t *  s: stopPropagation          : number/undefined\n\t *  i: stopImmediatePropagation : number/undefined\n\t *  p: preventDefault           : number/undefined\n\t *  h: shiftKey                 : number/undefined\n\t *  a: altKey                   : number/undefined\n\t *  c: ctrlKey                  : number/undefined\n\t *  t: metaKey                  : number/undefined\n\t *  u: capture                  : number/undefined\n\t *  e: passive                  : number/undefined\n\t *  o: once                     : number/undefined\n\t *  k: keyCodes                 : array<number>/undefined\n\t */\n\n\tconst checkEventProps = (event) => {\n\t\tif (!!h !== !!event.shiftKey ||\n\t\t\t!!a !== !!event.altKey ||\n\t\t\t!!c !== !!event.ctrlKey ||\n\t\t\t!!t !== !!event.metaKey ||\n\t\t\t(k && k.indexOf(event.which) === -1)) return false\n\t\treturn true\n\t}\n\n\tconst handleStopOptions = (event) => {\n\t\tif (s) event.stopPropagation()\n\t\tif (i) event.stopImmediatePropagation()\n\t}\n\n\tlet eventOptions = {\n\t\tcapture: !!u\n\t}\n\n\tlet baseEventHandler = (event) => {\n\t\thandleStopOptions(event)\n\t\tif (p && !e) event.preventDefault()\n\t\thandler(event)\n\t}\n\n\tlet eventHandler = (event) => {\n\t\tif (!checkEventProps(event)) return\n\t\tbaseEventHandler(event)\n\t}\n\n\tif (e || o) {\n\t\tconst makePassiveEventHandler = () => {\n\t\t\tbaseEventHandler = (event) => {\n\t\t\t\thandleStopOptions(event)\n\t\t\t\tsetTimeout(() => handler(event), 0)\n\t\t\t}\n\t\t\teventHandler = (event) => {\n\t\t\t\tif (!checkEventProps(event)) return\n\t\t\t\tbaseEventHandler(event)\n\t\t\t}\n\t\t}\n\n\t\tconst makeOnceEventHandler = () => {\n\t\t\tconst removeListener = custom && '$off' || 'removeEventListener'\n\t\t\teventHandler = (event) => {\n\t\t\t\tif (!checkEventProps(event)) return\n\t\t\t\telement[removeListener](l, eventHandler, eventOptions)\n\t\t\t\tbaseEventHandler(event)\n\t\t\t}\n\t\t}\n\n\t\tif (DOM.passiveSupported || DOM.onceSupported) {\n\t\t\tif (e === 0 && DOM.passiveSupported) {\n\t\t\t\teventOptions.passive = false\n\t\t\t} else if (e) {\n\t\t\t\tif (DOM.passiveSupported) eventOptions.passive = true\n\t\t\t\telse makePassiveEventHandler()\n\t\t\t}\n\n\t\t\tif (o) {\n\t\t\t\tif (DOM.onceSupported) eventOptions.once = true\n\t\t\t\telse makeOnceEventHandler()\n\t\t\t}\n\n\t\t} else {\n\t\t\tif (e) makePassiveEventHandler()\n\t\t\tif (o) makeOnceEventHandler()\n\t\t}\n\t}\n\n\tconst addListener = custom && '$on' || 'addEventListener'\n\telement[addListener](l, eventHandler, eventOptions)\n}\n\n// eslint-disable-next-line max-params\nconst addValListener = (ctx, trigger, updateLock, element, lastNode, key, expr, custom) => {\n\tconst addListener = custom && '$on' || 'addEventListener'\n\tconst {parentNode, _key} = initBinding(ctx, {bind: expr})\n\n\tconst handler = () => {\n\t\tupdateLock.locked = true\n\t\tinform()\n\t\tparentNode[_key] = lastNode[key]\n\t\texec()\n\t\tupdateLock.locked = false\n\t}\n\n\tconst eventOptions = {\n\t\tcapture: true\n\t}\n\n\tif (trigger) {\n\t\tapplyEventListener(element, custom, handler, trigger)\n\t} else if (key === 'value') {\n\t\t// Listen to input, keyup and change events in order to work in most browsers.\n\t\telement[addListener]('input', handler, eventOptions)\n\t\telement[addListener]('keyup', handler, eventOptions)\n\t\telement[addListener]('change', handler, eventOptions)\n\t} else {\n\t\tconst dispatch = custom && '$dispatch' || 'dispatchEvent'\n\t\telement[addListener]('change', () => {\n\t\t\t// Trigger change to the element it-self\n\t\t\telement[dispatch](getEvent('__ef_change_event__'), {bubbles: false, cancelable: false})\n\t\t\tif (element.tagName === 'INPUT' && element.type === 'radio' && element.name !== '') {\n\t\t\t\t// Trigger change to the the same named radios\n\t\t\t\tconst radios = DOM.document.querySelectorAll(`input[name=${element.name}][type=radio]`)\n\t\t\t\tif (radios) {\n\t\t\t\t\tconst selected = ARR.copy(radios)\n\t\t\t\t\tARR.remove(selected, element)\n\n\t\t\t\t\t/* Event triggering could cause unwanted render triggers\n\t\t\t\t\t * no better ways came up at the moment\n\t\t\t\t\t */\n\t\t\t\t\tfor (let i of selected) i.dispatchEvent(getEvent('__ef_change_event__'))\n\t\t\t\t}\n\t\t\t}\n\t\t}, eventOptions)\n\t\t// Use custom event to avoid loops and conflicts\n\t\telement[addListener]('__ef_change_event__', handler)\n\t}\n}\n\nconst getAttrHandler = (ctx, {element, key, custom}) => {\n\t// Pass directly to custom component\n\tif (custom) return (val) => {\n\t\telement[key] = val\n\t}\n\n\t// Beautify class name\n\tif (key === 'class') return (val) => {\n\t\tval = `${val}`.replace(/\\s+/g, ' ').trim()\n\t\t// Remove attribute when value is empty\n\t\tif (!val) return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n\n\t// Handle namespace\n\tif (hasColon(key)) {\n\t\tconst [prefix] = splitByColon(key)\n\t\tconst namespace = ctx.localNamespaces[prefix] || getNamespace(prefix)\n\t\treturn (val) => {\n\t\t\t// Remove attribute when value is empty\n\t\t\tif (val === '') return element.removeAttributeNS(namespace, key)\n\t\t\telement.setAttributeNS(namespace, key, val)\n\t\t}\n\t}\n\n\treturn (val) => {\n\t\t// Remove attribute when value is empty\n\t\tif (val === '') return element.removeAttribute(key)\n\t\telement.setAttribute(key, val)\n\t}\n}\n\n// eslint-disable-next-line max-params\nconst addAttr = (ctx, element, attr, key, custom) => {\n\tif (typeValid(attr)) {\n\t\tif (custom) {\n\t\t\tif (attr === '') {\n\t\t\t\telement[key] = true\n\t\t\t} else {\n\t\t\t\telement[key] = attr\n\t\t\t}\n\n\t\t\treturn\n\t\t}\n\t\t// Do not set or update `is` again\n\t\tif (key === 'is') return\n\t\t// Handle namespaces\n\t\tif (hasColon(key)) {\n\t\t\tconst [prefix] = splitByColon(key)\n\t\t\tif (prefix !== 'xmlns') {\n\t\t\t\tconst ns = ctx.localNamespaces[prefix] || getNamespace(prefix)\n\t\t\t\treturn element.setAttributeNS(ns, key, attr)\n\t\t\t}\n\t\t}\n\t\treturn element.setAttribute(key, attr)\n\t}\n\n\tconst handler = getAttrHandler(ctx, {element, key, custom})\n\tregTmpl(ctx, attr, handler)\n}\n\n// eslint-disable-next-line max-params\nconst addProp = (ctx, element, value, propPath, trigger, updateOnly, custom) => {\n\tconst keyPath = ARR.copy(propPath)\n\tconst lastKey = keyPath.pop()\n\tif (custom) keyPath.unshift('$data')\n\tconst lastNode = resolvePath(keyPath, element)\n\tif (typeValid(value)) lastNode[lastKey] = value\n\telse {\n\t\tconst updateLock = {locked: false}\n\t\tlet handler = null\n\n\t\tif (updateOnly) {\n\t\t\thandler = () => {\n\t\t\t\tupdateLock.locked = false\n\t\t\t}\n\t\t} else {\n\t\t\thandler = (val) => {\n\t\t\t\tif (!updateLock.locked && lastNode[lastKey] !== val) {\n\t\t\t\t\tlastNode[lastKey] = val\n\t\t\t\t}\n\t\t\t\tupdateLock.locked = false\n\t\t\t}\n\t\t}\n\n\t\tregTmpl(ctx, value, handler)\n\t\tif (\n\t\t\ttrigger ||\n\t\t\t(propPath.length === 1 && (lastKey === 'value' || lastKey === 'checked')) &&\n\t\t\t!value[0]\n\t\t) {\n\t\t\taddValListener(ctx, trigger, updateLock, element, lastNode, lastKey, value[1], custom)\n\t\t}\n\t}\n}\n\nconst rawHandler = val => val\n\n// eslint-disable-next-line max-params\nconst addEvent = (ctx, element, trigger, custom) => {\n\n\t/*\n\t *  m: method                   : string\n\t *  v: value                    : string/array/undefined\n\t */\n\tconst {m, v} = trigger\n\tconst _handler = regTmpl(ctx, v, rawHandler)\n\n\tconst callEventHandler = (event) => {\n\t\tconst value = _handler()\n\t\tif (ctx.methods[m]) ctx.methods[m]({e: event, event, value, state: ctx.state})\n\t\telse if (m) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(`Bubbling up event '${m}'...`)\n\t\t\tevent.data = value\n\t\t\tctx.state.$emit(m, event)\n\t\t}\n\t}\n\n\tapplyEventListener(element, custom, callEventHandler, trigger)\n}\n\n// eslint-disable-next-line max-params\nconst createElement = (ctx, info, namespace, fragment, custom) => {\n\tif (fragment) return [new EFFragment(), 'fragment']\n\n\t/*\n\t *  t: tag           : class | string | int, 0 means fragment\n\t *  a: attr          : object\n\t *  p: prop          : object\n\t *  e: event trigger : array\n\t *  r: reference     : string\n\t */\n\tconst {t, a, p, e, r} = info\n\tconst tagName = t\n\tconst tagContent = ctx.scope[t] || t\n\tconst tagType = typeof tagContent\n\tconst element = getElement(tagType, tagName, tagContent, a, r, ctx.refs, namespace)\n\tif (a) for (let key in a) addAttr(ctx, element, a[key], key, custom)\n\tif (p) for (let [propPath, value, trigger, updateOnly] of p) addProp(ctx, element, value, propPath, trigger, updateOnly, custom)\n\tif (e) for (let trigger of e) addEvent(ctx, element, trigger, custom)\n\n\treturn [element, tagType]\n}\n\nexport {createElement, typeValid}\n","const getGetter = ({base, key}, {checkTrue, get, set}) => {\n\tif (get) {\n\t\tif (!set) throw new Error('[EF] Setter must be defined when getter exists')\n\t\treturn get\n\t}\n\n\tif (checkTrue) return function() {\n\t\treturn checkTrue(base(this)[key], this)\n\t}\n\n\treturn function() {\n\t\treturn base(this)[key]\n\t}\n}\n\nconst getSetter = ({base, key}, {checkTrue, trueVal, falseVal, get, set}) => {\n\tif (set) {\n\t\tif (!get) throw new Error('[EF] Getter must be defined when setter exists')\n\t\treturn set\n\t}\n\n\tif (checkTrue) return function(val) {\n\t\tconst baseNode = base(this)\n\t\tconst _trueVal = trueVal\n\t\tconst _falseVal = falseVal\n\n\t\tif (typeof trueVal !== 'function') trueVal = () => _trueVal\n\t\tif (typeof falseVal !== 'function') falseVal = () => _falseVal\n\n\t\tif (val) baseNode[key] = trueVal(this)\n\t\telse baseNode[key] = falseVal(this)\n\t}\n\n\treturn function(val) {\n\t\tbase(this)[key] = val\n\t}\n}\n\nconst defaultRoot = state => state.$data\nconst getBase = (root) => {\n\tif (!root) return defaultRoot\n\tif (typeof root === 'function') return root\n\tif (typeof root === 'string') root = root.split('.')\n\treturn (base) => {\n\t\tfor (let key of root) base = base[key]\n\t\treturn base\n\t}\n}\n\n/**\n * @typedef {import('./renderer.js').EFBaseClass} EFBaseClass\n */\n\n/**\n * Definition of an attribute mapping\n * @typedef {Object} AttrDef\n * @property {string=} key - key to be accessed on base, default to `attr`\n * @property {Function=} base - a function that returns the base of the key, default returns $data\n * @property {bool=} checkTrue - a function returns true or false based on input value\n * @property {*=} trueVal - value when true, only used when checkTrue is set\n * @property {*=} falseVal - value when false, only used when checkTrue is set\n * @property {Function=} get - getter, will ignore all other settings except set\n * @property {Function=} set - setter, will ignore all other settings except get\n */\n\n/**\n * Data to attribute mapping helper\n * @template {EFBaseClass} T\n * @param {T} tpl - Component class to be mapped\n * @param {Object.<string,AttrDef>} attrMap - Attributes to be mapped\n * @returns {T} - Mapped component class\n */\nconst mapAttrs = (tpl, attrMap) => {\n\tfor (let attr in attrMap) {\n\t\tconst options = attrMap[attr]\n\n\t\tconst base = getBase(options.base)\n\t\tconst key = options.key || attr\n\n\t\tconst basicProperty = {base, key}\n\n\t\tconst get = getGetter(basicProperty, options)\n\t\tconst set = getSetter(basicProperty, options)\n\n\t\tObject.defineProperty(tpl.prototype, attr, {\n\t\t\tget,\n\t\t\tset,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t})\n\t}\n\n\treturn tpl\n}\n\nexport default mapAttrs\n","import ARR from './utils/array-helper.js'\n\nconst userQueue = []\nlet count = 0\n\nconst modificationQueue = {\n\tfirst: null,\n\tlast: null\n}\n\nconst domQueue = {\n\tfirst: null,\n\tlast: null\n}\n\n// const queue = handlers => modificationQueue.push(...handlers)\nconst onNextRender = handler => userQueue.push(handler)\n\nconst addQueue = (ctx, handler) => {\n\tif (handler === ctx.last) return\n\n\tif (handler.__next) handler.__next.__prev = handler.__prev\n\tif (handler.__prev) handler.__prev.__next = handler.__next\n\n\tif (ctx.first) {\n\t\tif (handler === ctx.first) ctx.first = handler.__next\n\t} else ctx.first = handler\n\n\tif (ctx.last) {\n\t\tctx.last.__next = handler\n\t\thandler.__prev = ctx.last\n\t}\n\n\tctx.last = handler\n\tctx.first.__prev = null\n\tctx.last.__next = null\n}\n\nconst runQueue = (ctx) => {\n\tlet currentFn = ctx.first\n\tif (!currentFn) return\n\n\tconst queueArr = []\n\twhile (currentFn) {\n\t\tconst nextFn = currentFn.__next\n\t\tcurrentFn.__prev = null\n\t\tcurrentFn.__next = null\n\t\tqueueArr.push(currentFn)\n\t\tcurrentFn = nextFn\n\t}\n\n\tctx.first = null\n\tctx.last = null\n\n\tfor (let i of queueArr) i()\n}\n\nconst queue = (...handlers) => {\n\tfor (let i of handlers) addQueue(modificationQueue, i)\n}\n\nconst queueDom = (handler) => {\n\taddQueue(domQueue, handler)\n}\n\n/**\n * @returns {boolean} - Is render paused\n */\nconst isPaused = () => count > 0\n\n/**\n * Add 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @returns {number} - Render count down\n */\nconst inform = () => {\n\tcount += 1\n\treturn count\n}\n\n/**\n * Minus 1 to render count down.\n * When countdown becomes 0, render will be triggered.\n * @param {boolean=} immediate - Render immediately, will force countdown become 0\n * @returns {number} - Render count down\n */\nconst exec = (immediate) => {\n\tif (!immediate && (count -= 1) > 0) return count\n\n\tcount = 1\n\n\twhile (modificationQueue.first) runQueue(modificationQueue)\n\twhile (domQueue.first) runQueue(domQueue)\n\n\tcount = 0\n\n\t// Execute user queue after DOM update\n\tif (userQueue.length) {\n\t\tconst _userQueue = ARR.copy(userQueue)\n\t\tARR.empty(userQueue)\n\t\tsetTimeout(() => {\n\t\t\tfor (let i of _userQueue) i()\n\t\t}, 0)\n\t}\n\n\treturn count\n}\n\n/**\n * Run callback in a safe way, without worrying about unhandled errors may break rendering.\n * @param {Function} cb - Callback function to be executed safly\n * @returns {(void|Error)} - Error that happens when executing callback\n */\nconst bundle = (cb) => {\n\tinform()\n\ttry {\n\t\t// eslint-disable-next-line callback-return\n\t\texec(cb(inform, exec))\n\t} catch (e) {\n\t\texec()\n\t\treturn e\n\t}\n}\n\nexport { queue, queueDom, onNextRender, inform, exec, bundle, isPaused }\n","import {create, nullComponent, checkDestroyed} from './creator.js'\nimport initBinding from './binding.js'\nimport {queueDom, inform, exec} from './render-queue.js'\nimport {resolveSubscriber} from './resolver.js'\nimport mapAttrs from './map-attrs.js'\nimport {DOM, EFFragment, EFMountPoint} from './utils/dom-helper.js'\nimport ARR from './utils/array-helper.js'\nimport {assign, legacyAssign} from './utils/polyfills.js'\nimport isInstance from './utils/fast-instance-of.js'\nimport typeOf from './utils/type-of.js'\nimport dbg from './utils/debug.js'\nimport getEvent from './utils/event-helper.js'\nimport mountOptions from '../mount-options.js'\n\nimport shared from './utils/global-shared.js'\n\nconst unsubscribe = (pathStr, fn, subscribers) => {\n\tconst subscriberNode = resolveSubscriber(pathStr, subscribers)\n\tARR.remove(subscriberNode, fn)\n}\n\n/**\n * @typedef {Array} EFAST\n * @typedef {Object.<string,EFBaseComponent>} EFTemplateScope\n */\n\n/**\n * @typedef {Object} EFSubscriberHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been subscribed\n */\n\n/**\n * @event Event\n */\n\n/**\n * @typedef {Object} EFEventHandlerArg\n * @property {EFBaseComponent} ctx - The component who calls the handler\n * @property {*} value - Value been passed to the event handler\n * @property {Event} event - Event object that has been triggered\n */\n\n/**\n * @typedef {Function} EFSubscriberHandlerMethod\n * @param {EFSubscriberHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * @typedef {Function} EFEventHandlerMethod\n * @param {EFEventHandlerArg} arg\n * @returns {void}\n */\n\n/**\n * The very basic ef component\n * @class EFBaseComponent\n * @param {EFAST} ast - ast for the component\n * @param {EFTemplateScope} scope - scope which contains custom components\n * @private {Object} $ctx - Inner component data, DO NOT TOUCH\n * @property {Object} $data - Data on component\n * @property {Object.<string,EFEventHandlerMethod>} $methods - Methods on component\n * @property {Object.<string,(EFBaseComponent|Node)>} $refs - References on component\n */\nconst EFBaseComponent = class {\n\n\tstatic initData() {\n\t\treturn\n\t}\n\tstatic initMethods() {\n\t\treturn\n\t}\n\tstatic initScope() {\n\t\treturn\n\t}\n\n\tstatic __defaultScope() {\n\t\treturn {}\n\t}\n\n\tstatic init(self, $data, watch) {\n\t\tconst data = this.initData(self, $data, watch)\n\t\tconst methods = this.initMethods(self, $data, watch)\n\t\tconst scope = this.initScope(self, $data, watch)\n\n\t\treturn { data, methods, scope }\n\t}\n\n\t/**\n\t * Create an EFBaseComponent with ef AST\n\t * @param {EFAST} ast - ast for the component\n\t * @param {EFTemplateScope=} userScope - scope which contains custom components\n\t */\n\tconstructor(ast, userScope = {}) {\n\t\t// const newTarget = new.target\n\t\tconst newTarget = this.constructor\n\n\t\tif (process.env.NODE_ENV !== 'production' && newTarget === EFBaseComponent) {\n\t\t\tthrow new TypeError('[EF] Illegal constructor. EFBaseComponent must not be used directly!')\n\t\t}\n\n\t\tconst children = {}\n\t\tconst refs = {}\n\t\tconst data = {}\n\t\tconst handlers = {}\n\t\tconst subscribers = {}\n\n\t\tconst isFragment = ast[0].t === 0\n\n\t\tlet placeholder = null\n\t\tlet eventBus = null\n\t\tlet element = null\n\n\t\tif (process.env.NODE_ENV === 'production') placeholder = DOM.document.createTextNode('')\n\t\telse placeholder = DOM.document.createComment(`<${this.constructor.name}/>`)\n\n\n\t\tif (DOM.textNodeSupportsEvent) eventBus = placeholder\n\t\telse eventBus = document.createElement('i')\n\n\t\tconst nodeInfo = {\n\t\t\tplaceholder,\n\t\t\teventBus,\n\t\t\tparent: null,\n\t\t\tkey: null\n\t\t}\n\n\t\tconst mount = () => {\n\t\t\tconst parentNode = placeholder.parentNode\n\t\t\tif (mount.remove || !parentNode) {\n\t\t\t\tDOM.remove(element)\n\t\t\t\tmount.remove = false\n\t\t\t} else if (parentNode) {\n\t\t\t\tDOM.before(placeholder, element)\n\t\t\t\tDOM.remove(placeholder)\n\t\t\t}\n\t\t}\n\n\t\tconst ctx = {\n\t\t\tast, mount, refs, data,\n\t\t\thandlers, subscribers, nodeInfo,\n\t\t\tchildren, state: this, isFragment,\n\t\t\tlocalNamespaces: newTarget.__local_namespaces,\n\t\t\tself: this, constructor: newTarget\n\t\t}\n\n\t\tObject.defineProperty(this, '$ctx', {\n\t\t\tvalue: ctx,\n\t\t\tenumerable: false,\n\t\t\tconfigurable: true\n\t\t})\n\n\t\tconst watchers = []\n\t\tconst watch = (path, handler) => {\n\t\t\tconst subscriberInfo = [path, handler]\n\t\t\twatchers.push(subscriberInfo)\n\t\t\treturn () => {\n\t\t\t\tif (element) this.$unsubscribe(path, handler)\n\t\t\t\telse ARR.remove(subscriberInfo)\n\t\t\t}\n\t\t}\n\n\t\tconst {\n\t\t\tdata: innerData,\n\t\t\tmethods,\n\t\t\tscope,\n\t\t\tbeforeMount,\n\t\t\tafterMount,\n\t\t\tbeforeUmount,\n\t\t\tafterUmount,\n\t\t\tbeforeDestroy,\n\t\t\tafterDestroy,\n\t\t\tonCreated\n\t\t} = newTarget.init(this, data, watch)\n\n\t\tassign(ctx, {\n\t\t\tinnerData: innerData || {},\n\t\t\tmethods: methods || {},\n\t\t\tscope: assign(newTarget.__defaultScope(), scope, userScope),\n\t\t\tbeforeMount,\n\t\t\tafterMount,\n\t\t\tbeforeUmount,\n\t\t\tafterUmount,\n\t\t\tbeforeDestroy,\n\t\t\tafterDestroy\n\t\t})\n\n\t\telement = create(ctx, {node: ast, namespace: ''})\n\n\t\tlet firstElement = element\n\n\t\twhile (!DOM.isNodeInstance(firstElement)) {\n\t\t\tif (isInstance(firstElement, EFFragment)) firstElement = firstElement.firstElement\n\t\t\telse firstElement = firstElement.$ctx.nodeInfo.element\n\t\t}\n\n\t\tnodeInfo.element = element\n\t\tnodeInfo.firstElement = firstElement\n\n\t\tfor (let [path, handler] of watchers) {\n\t\t\tthis.$subscribe(path, handler)\n\t\t}\n\n\t\tif (onCreated) onCreated()\n\t}\n\n\tget $data() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.data\n\t}\n\n\tset $data(newData) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tassign(this.$ctx.data, newData)\n\t\texec()\n\t}\n\n\tget $methods() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.methods\n\t}\n\n\n\tset $methods(newMethods) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.methods = newMethods\n\t}\n\n\tget $refs() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.refs\n\t}\n\n\t/**\n\t * @typedef {import('../mount-options.js').EFMountConfig} EFMountConfig\n\t */\n\n\t/**\n\t * Mount component to a specitic position\n\t * @param {EFMountConfig} config - Mount contigurations\n\t * @returns {number} - Render count down\n\t */\n\t$mount({target, option, parent, key}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount, beforeMount, afterMount } = this.$ctx\n\n\t\tlet ret = null\n\n\t\tif (typeof target === 'string') {\n\t\t\ttarget = document.querySelector(target)\n\t\t\tif (!target) throw new Error('Mount target not found!')\n\t\t}\n\n\t\tif (beforeMount) beforeMount()\n\n\t\tinform()\n\t\tif (nodeInfo.parent) {\n\t\t\tthis.$umount()\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn('Component detached from previous mount point.')\n\t\t}\n\n\t\tif (!parent) parent = target\n\t\tif (!key) key = '__DIRECTMOUNT__'\n\t\tnodeInfo.parent = parent\n\t\tnodeInfo.key = key\n\t\tmount.remove = false\n\t\tqueueDom(mount)\n\n\t\tconst placeholder = nodeInfo.placeholder\n\n\t\tif (target) {\n\t\t\tswitch (option) {\n\t\t\t\tcase mountOptions.BEFORE: {\n\t\t\t\t\tDOM.before(target, placeholder)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase mountOptions.AFTER: {\n\t\t\t\t\tDOM.after(target, placeholder)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase mountOptions.REPLACE: {\n\t\t\t\t\tDOM.before(target, placeholder)\n\t\t\t\t\tDOM.remove(target)\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t\tcase mountOptions.APPEND:\n\t\t\t\tdefault: {\n\t\t\t\t\tDOM.append(target, placeholder)\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = exec()\n\t\t} else {\n\t\t\texec()\n\t\t\tret = placeholder\n\t\t}\n\n\t\tif (afterMount) afterMount()\n\n\t\treturn ret\n\t}\n\n\t/**\n\t * @returns {number} - Render count down\n\t */\n\t$umount() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { nodeInfo, mount, beforeUmount, afterUmount } = this.$ctx\n\t\tconst { parent, key } = nodeInfo\n\t\tnodeInfo.parent = null\n\t\tnodeInfo.key = null\n\n\t\tif (beforeUmount) beforeUmount()\n\n\t\tinform()\n\t\tif (parent) {\n\t\t\tif (key !== '__DIRECTMOUNT__') {\n\t\t\t\tif (parent[key]) {\n\t\t\t\t\tif (ARR.isArray(parent[key])) {\n\t\t\t\t\t\t// Remove self from parent list mount point\n\t\t\t\t\t\tARR.remove(parent[key], this)\n\t\t\t\t\t} else parent[key] = nullComponent\n\t\t\t\t}\n\t\t\t// Else Remove elements from fragment parent\n\t\t\t} else if (isInstance(parent, EFFragment)) parent.$ctx.nodeInfo.element.removeChild(nodeInfo.element)\n\t\t}\n\n\t\tmount.remove = true\n\t\tqueueDom(mount)\n\n\t\tconst ret = exec()\n\n\t\tif (afterUmount) afterUmount()\n\n\t\treturn ret\n\t}\n\n\t/**\n\t * Subscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be added\n\t * @returns {void}\n\t */\n\t$subscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst ctx = this.$ctx\n\t\tconst _path = pathStr.split('.')\n\t\tconst { dataNode, subscriberNode, _key } = initBinding(ctx, {bind: [_path]})\n\t\tinform()\n\t\t// Execute the subscriber function immediately\n\t\ttry {\n\t\t\tsubscriber({state: this, value: dataNode[_key]})\n\t\t\t// Put the subscriber inside the subscriberNode\n\t\t\tsubscriberNode.push(subscriber)\n\t\t} catch (e) {\n\t\t\tdbg.error('Error caught when registering subscriber:\\n', e)\n\t\t}\n\t\texec()\n\t}\n\n\t/**\n\t * Unsubscribe a value's changing\n\t * @param {string} pathStr - Path string to the subribed value based on `$data`, splitted by `.`\n\t * @param {EFSubscriberHandlerMethod} subscriber - Subscription event handler to be removed\n\t * @returns {void}\n\t */\n\t$unsubscribe(pathStr, subscriber) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { subscribers } = this.$ctx\n\t\tunsubscribe(pathStr, subscriber, subscribers)\n\t}\n\n\t/**\n\t * Update the component's state with a new state\n\t * @param {Object} newState - New state to be set on this component\n\t * @returns {void}\n\t */\n\t$update(newState) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tinform()\n\t\tlegacyAssign(this, newState)\n\t\texec()\n\t}\n\n\t/**\n\t * Call a defined method with value and extra arguments\n\t * @param {string} methodName - The name of the method to be called\n\t * @param {object=} scope - Scope for this method call\n\t * @param {...*} args - Other arguments\n\t * @returns {*} - Return value of the called method\n\t */\n\t$call(methodName, scope = {}, ...args) {\n\t\treturn this.$methods[methodName](assign({}, scope, {state: this}), ...args)\n\t}\n\n\t/**\n\t * Fire a custom event using an Event object on this component\n\t * @param {Event} event - Event object to be dispatched on this component\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$dispatch(event) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.eventBus.dispatchEvent(event)\n\t}\n\n\t/**\n\t * @typedef {import('./utils/event-helper.js').EFEventOptions} EFEventOptions\n\t */\n\n\t/**\n\t * Fire a custom event using event name on this component\n\t * @param {string} eventName - Name of the custom event\n\t * @param {EFEventOptions} options - Event Options\n\t * @returns {*} - Same as the return of Node.dispatchEvent\n\t */\n\t$emit(eventName, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$dispatch(getEvent(eventName, options))\n\t}\n\n\t/**\n\t * Add custom event listener on this component\n\t * @param {string} eventName - Name of the event\n\t * @param {function} handler - Handler for the event\n\t * @param {object|boolean} options - Event listener options or useCapture\n\t * @returns {function} - Event Handler disposal method\n\t */\n\t$on(eventName, handler, options = {}) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tthis.$ctx.nodeInfo.eventBus.addEventListener(eventName, handler, options)\n\t\treturn () => this.$off(eventName, handler, options)\n\t}\n\n\t/**\n\t * Remove custom event listener on this component\n\t * @param {string} eventName - Name of the event\n\t * @param {function} handler - Handler for the event\n\t * @param {object|boolean} options - Event listener options or useCapture\n\t * @returns {*} - Same as the return of Node.removeEventListener\n\t */\n\t$off(eventName, handler, options) {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\treturn this.$ctx.nodeInfo.eventBus.removeEventListener(eventName, handler, options)\n\t}\n\n\t/**\n\t * Destroy this component\n\t * @returns {number} - Render count down\n\t */\n\t$destroy() {\n\t\tif (process.env.NODE_ENV !== 'production') checkDestroyed(this)\n\t\tconst { children, beforeDestroy, afterDestroy } = this.$ctx\n\n\t\tif (beforeDestroy) beforeDestroy()\n\n\t\tinform()\n\t\tthis.$umount()\n\t\tfor (let i in children) children[i].anchor[EFMountPoint] = null\n\t\t// Detatch all mounted components\n\t\tfor (let i in this) {\n\t\t\tif (typeOf(this[i]) === 'array') this[i].clear()\n\t\t\telse this[i] = null\n\t\t}\n\t\t// Remove context\n\t\tdelete this.$ctx\n\t\t// Render\n\t\tconst ret = exec()\n\n\t\tif (afterDestroy) afterDestroy()\n\n\t\treturn ret\n\t}\n}\n\n/**\n * @typedef {typeof EFBaseComponent} EFBaseClass\n */\n\nconst fragmentAST = [{t: 0}]\n\n/**\n * ef component node wrapper\n * Better using this than Fragments if wrapping only HTML elements.\n * @class EFNodeWrapper\n * @extends EFBaseComponent\n * @param {...Node} nodes - Nodes to be wrapped\n * @property {Array<Node>} - Nodes that are wrapped\n */\nconst EFNodeWrapper = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given nodes into an ef component\n\t * @param  {...Node} nodes - Nodes to be wrapped\n\t */\n\tconstructor(...nodes) {\n\t\tsuper(fragmentAST)\n\n\t\t// element.append(...nodes)\n\t\tconst element = this.$ctx.nodeInfo.element\n\t\t// const childrenArr = element.$children\n\n\t\t// childrenArr.push(...nodes)\n\t\telement.append(...nodes)\n\n\t\t// if (process.env.NODE_ENV !== 'production') {\n\t\t// \tchildrenArr.push(ARR.remove(childrenArr, childrenArr[1]))\n\t\t// }\n\n\t\tthis.$ctx.elements = nodes\n\t}\n\n\tget $el() {\n\t\treturn this.$ctx.elements\n\t}\n}\n\n/**\n * Component fragment wrapper\n * @class Fragment\n * @extends EFBaseComponent\n * @param {...*} children - Things to be wrapped into an ef component\n */\nconst Fragment = class extends EFBaseComponent {\n\tconstructor(...children) {\n\t\tsuper([{t: 0}, ...children])\n\t}\n}\n\nconst textFragmentAst = [{t: 0},[['t']]]\n\n/**\n * ef component text wrapper\n * @class EFTextFragment\n * @extends EFBaseComponent\n * @param {string} text - String to be wrapped\n * @property {string} text - Text on the fragment component\n */\nconst EFTextFragment = class extends EFBaseComponent {\n\n\t/**\n\t * Wrap given text into an ef component\n\t * @param {string} text - String to be wrapped\n\t */\n\tconstructor(text) {\n\t\tinform()\n\t\tsuper(textFragmentAst)\n\t\tthis.text = text\n\t\texec()\n\t}\n}\nmapAttrs(EFTextFragment, {text: {key: 't'}})\n\n\n/**\n * Transform almost anyting into ef component\n * @template {value} T\n * @param {T} value - Things to be transformed into ef component\n * @returns {(EFNodeWrapper|EFTextFragment|T)} - Wrapped component or value it self if not supports converting\n */\nconst toEFComponent = (value) => {\n\tif (value === null || typeof value === 'undefined' || value instanceof EFBaseComponent) return value\n\n\tif (value !== nullComponent) {\n\t\tif (DOM.isNodeInstance(value)) return new EFNodeWrapper(value)\n\t\telse if (typeof value === 'string') return new EFTextFragment(value)\n\t\telse return new EFTextFragment(JSON.stringify(value))\n\t}\n}\n\nshared.EFBaseComponent = EFBaseComponent\nshared.EFNodeWrapper = EFNodeWrapper\nshared.toEFComponent = toEFComponent\n\nexport {EFBaseComponent, EFNodeWrapper, EFTextFragment, Fragment, toEFComponent}\n","import {inform, exec} from './render-queue.js'\nimport {assign} from './utils/polyfills.js'\n\nconst resolveAllPath = ({_path, handlers, subscribers, innerData}) => {\n\tfor (let i of _path) {\n\t\tif (!handlers[i]) handlers[i] = {}\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tif (!innerData[i]) innerData[i] = {}\n\t\thandlers = handlers[i]\n\t\tsubscribers = subscribers[i]\n\t\tinnerData = innerData[i]\n\t}\n\treturn {\n\t\thandlerNode: handlers,\n\t\tsubscriberNode: subscribers,\n\t\tdataNode: innerData\n\t}\n}\n\n// Workaround for the third bug of buble:\n// https://github.com/bublejs/buble/issues/106\nconst defineNode = (key, obj) => {\n\tconst node = {}\n\tObject.defineProperty(obj, key, {\n\t\tget() {\n\t\t\treturn node\n\t\t},\n\t\tset(data) {\n\t\t\tinform()\n\t\t\tassign(node, data)\n\t\t\texec()\n\t\t},\n\t\tconfigurable: false,\n\t\tenumerable: true\n\t})\n\treturn node\n}\n\nconst reactivePathReducer = (obj, key) => obj[key] || defineNode(key, obj)\n\nconst resolveReactivePath = (_path, obj) => _path.reduce(reactivePathReducer, obj)\n\nconst resolvePath = (_path, obj) => {\n\tfor (let i of _path) {\n\t\tif (!obj[i]) obj[i] = {}\n\t\tobj = obj[i]\n\t}\n\treturn obj\n}\n\nconst resolve = ({_path, _key, data, handlers, subscribers, innerData}) => {\n\tconst parentNode = resolveReactivePath(_path, data)\n\tconst {handlerNode, subscriberNode, dataNode} = resolveAllPath({_path, handlers, subscribers, innerData})\n\t// if (!handlerNode[_key]) handlerNode[_key] = []\n\tlet _handlerNode = handlerNode[_key]\n\tlet _subscriberNode = subscriberNode[_key]\n\tif (!_subscriberNode) {\n\t\t_handlerNode = handlerNode[_key] = []\n\t\t_subscriberNode = subscriberNode[_key] = []\n\t}\n\tif (!Object.prototype.hasOwnProperty.call(dataNode, _key)) dataNode[_key] = parentNode[_key]\n\t// return {parentNode, handlerNode: handlerNode[_key], subscriberNode: subscriberNode[_key], dataNode}\n\treturn {parentNode, handlerNode: _handlerNode, subscriberNode: _subscriberNode, dataNode}\n}\n\nconst resolveSubscriber = (_path, subscribers) => {\n\tconst pathArr = _path.split('.')\n\tconst key = pathArr.pop()\n\tfor (let i of pathArr) {\n\t\tif (!subscribers[i]) subscribers[i] = {}\n\t\tsubscribers = subscribers[i]\n\t}\n\treturn subscribers[key]\n}\n\nexport {resolveReactivePath, resolvePath, resolve, resolveSubscriber}\n","const SavedArray = Array\nconst proto = SavedArray.prototype\n\nconst ARR = {\n\tcopy(arr) {\n\t\treturn proto.slice.call(arr, 0)\n\t},\n\tempty(arr) {\n\t\tarr.length = 0\n\t\treturn arr\n\t},\n\tequals(left, right) {\n\t\tif (!SavedArray.isArray(right)) return false\n\t\tif (left === right) return true\n\t\tif (left.length !== right.length) return false\n\t\tfor (let i = 0, l = left.length; i < l; i++) {\n\t\t\tif (left[i] !== right[i]) return false\n\t\t}\n\t\treturn true\n\t},\n\tpop(arr) {\n\t\treturn proto.pop.call(arr)\n\t},\n\tpush(arr, ...items) {\n\t\treturn proto.push.apply(arr, items)\n\t},\n\tremove(arr, item) {\n\t\tconst index = proto.indexOf.call(arr, item)\n\t\tif (index > -1) {\n\t\t\tproto.splice.call(arr, index, 1)\n\t\t\treturn item\n\t\t}\n\t},\n\treverse(arr) {\n\t\treturn proto.reverse.call(arr)\n\t},\n\tshift(arr) {\n\t\treturn proto.shift.call(arr)\n\t},\n\tslice(arr, index, length) {\n\t\treturn proto.slice.call(arr, index, length)\n\t},\n\tsort(arr, fn) {\n\t\treturn proto.sort.call(arr, fn)\n\t},\n\tsplice(arr, ...args) {\n\t\treturn proto.splice.call(arr, ...args)\n\t},\n\tunshift(arr, ...items) {\n\t\treturn proto.unshift.apply(arr, items)\n\t},\n\tisArray(arr) {\n\t\treturn SavedArray.isArray(arr)\n\t}\n}\n\nexport default ARR\n","import noop from './noop.js'\n\nconst getDbg = () => {\n\tif (typeof console === 'undefined') {\n\t\tif (typeof print === 'undefined') {\n\t\t\treturn {\n\t\t\t\tlog: noop,\n\t\t\t\tinfo: noop,\n\t\t\t\twarn: noop,\n\t\t\t\terror: noop\n\t\t\t}\n\t\t}\n\n\t\tconst assemblePrintContent = (type, args) => `[EF][${type}] ${args.join(' ')}`\n\n\t\treturn {\n\t\t\tlog: (...args) => print(assemblePrintContent('LOG ', args)),\n\t\t\tinfo: (...args) => print(assemblePrintContent('INFO', args)),\n\t\t\twarn: (...args) => print(assemblePrintContent('WARN', args)),\n\t\t\terror: (...args) => print(assemblePrintContent('ERROR', args))\n\t\t}\n\t}\n\n\t// Wrap console functions for `[EF]` prefix\n\tconst strTpl = '[EF] %s'\n\treturn {\n\t\tlog: console.log && console.log.bind(console, strTpl) || noop,\n\t\tinfo: console.info && console.info.bind(console, strTpl) || noop,\n\t\twarn: console.warn && console.warn.bind(console, strTpl) || noop,\n\t\terror: console.error && console.error.bind(console, strTpl) || noop\n\t}\n}\n\nconst dbg = getDbg()\n\nexport default dbg\n","import {DOM, useFragment, useAnchor} from './dom-helper.js'\nimport ARR from './array-helper.js'\nimport {queueDom, inform, exec} from '../render-queue.js'\nimport shared from './global-shared.js'\n\nconst DOMARR = {\n\tempty() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$destroy()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tclear() {\n\t\tinform()\n\t\tfor (let i of ARR.copy(this)) i.$umount()\n\t\texec()\n\t\tARR.empty(this)\n\t},\n\tpop() {\n\t\tif (this.length === 0) return\n\t\tconst poped = ARR.pop(this)\n\t\tpoped.$umount()\n\t\treturn poped\n\t},\n\tpush({ctx, key, aftAnchor}, ...items) {\n\t\tif (!items.length) return\n\t\titems = items.map(shared.toEFComponent)\n\t\tinform()\n\t\tif (items.length === 1) {\n\t\t\tconst placeholder = items[0].$mount({parent: ctx.state, key})\n\t\t\tDOM.before(aftAnchor, placeholder)\n\t\t} else {\n\t\t\tuseFragment((tempFragment, recycleFragment) => {\n\t\t\t\tDOM.append(tempFragment, ...items.map(i => i.$mount({parent: ctx.state, key})))\n\t\t\t\tuseAnchor((tempAnchor, recycleAnchor) => {\n\t\t\t\t\tDOM.before(aftAnchor, tempAnchor)\n\t\t\t\t\tqueueDom(() => {\n\t\t\t\t\t\tDOM.after(tempAnchor, tempFragment)\n\t\t\t\t\t\trecycleAnchor()\n\t\t\t\t\t\trecycleFragment()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t\tconst ret = ARR.push(this, ...items)\n\t\texec()\n\t\treturn ret\n\t},\n\tremove(item) {\n\t\tif (this.indexOf(item) === -1) return\n\t\titem.$umount()\n\t\treturn item\n\t},\n\treverse({ctx, key, anchor}) {\n\t\tif (this.length === 0) return this\n\t\tconst tempArr = ARR.copy(this)\n\t\tconst elements = []\n\t\tinform()\n\t\tqueueDom(() => DOM.after(anchor, ...ARR.reverse(elements)))\n\t\tfor (let i of tempArr) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...ARR.reverse(tempArr))\n\t\texec()\n\t\treturn this\n\t},\n\tshift() {\n\t\tif (this.length === 0) return\n\t\tconst shifted = ARR.shift(this)\n\t\tshifted.$umount()\n\t\treturn shifted\n\t},\n\tsort({ctx, key, anchor}, fn) {\n\t\tif (this.length === 0) return this\n\t\tconst sorted = ARR.copy(ARR.sort(this, fn))\n\t\tconst elements = []\n\t\tinform()\n\t\tqueueDom(() => DOM.after(anchor, ...elements))\n\t\tfor (let i of sorted) {\n\t\t\ti.$umount()\n\t\t\tARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\t}\n\t\tARR.push(this, ...sorted)\n\t\texec()\n\t\treturn this\n\t},\n\tsplice({ctx, key, anchor}, ...args) {\n\t\tif (this.length === 0) return this\n\t\tconst [idx, , ...inserts] = args\n\t\tif (args.length > 2) args.length = 2\n\t\tconst spliced = ARR.splice(this, ...args)\n\t\tlet insertIdx = idx\n\t\tif (insertIdx < 0) insertIdx = this.length + idx\n\t\tif (insertIdx < 0) insertIdx = 0\n\t\tinform()\n\t\tfor (let i of spliced) i.$umount()\n\t\tif (inserts.length) {\n\t\t\tif (inserts.length === 1) {\n\t\t\t\tconst item = shared.toEFComponent(inserts[0])\n\t\t\t\titem.$mount({parent: ctx.state, key})\n\t\t\t\tconst placeholder = item.$ctx.nodeInfo.placeholder\n\t\t\t\tif (this[insertIdx]) DOM.before(this[insertIdx].$ctx.nodeInfo.firstElement, placeholder)\n\t\t\t\telse DOM.after(anchor, placeholder)\n\t\t\t\tARR.splice(this, insertIdx, 0, item)\n\t\t\t} else {\n\t\t\t\tuseAnchor((tempAnchor, recycleAnchor) => {\n\t\t\t\t\tif (this[insertIdx]) DOM.before(this[insertIdx].$ctx.nodeInfo.firstElement, tempAnchor)\n\t\t\t\t\telse DOM.after(anchor, tempAnchor)\n\t\t\t\t\tuseFragment((fragment, recycleFragment) => {\n\t\t\t\t\t\tconst insertItems = inserts.map(i => shared.toEFComponent(i))\n\t\t\t\t\t\tDOM.append(fragment, ...insertItems.map(i => i.$mount({parent: ctx.state, key})))\n\t\t\t\t\t\tARR.splice(this, insertIdx, 0, ...insertItems)\n\t\t\t\t\t\tqueueDom(() => {\n\t\t\t\t\t\t\tDOM.before(tempAnchor, fragment)\n\t\t\t\t\t\t\tDOM.remove(tempAnchor)\n\t\t\t\t\t\t\trecycleAnchor()\n\t\t\t\t\t\t\trecycleFragment()\n\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\texec()\n\t\treturn spliced\n\t},\n\tunshift({ctx, key, anchor}, ...items) {\n\t\tif (this.length === 0) return this.push(...items).length\n\t\titems = items.map(shared.toEFComponent)\n\t\tconst elements = []\n\t\tinform()\n\t\tqueueDom(() => DOM.after(anchor, ...elements))\n\t\tfor (let i of items) ARR.push(elements, i.$mount({parent: ctx.state, key}))\n\t\tconst ret = ARR.unshift(this, ...items)\n\t\texec()\n\t\treturn ret\n\t}\n}\n\nconst defineArr = (arr, info) => {\n\tObject.defineProperties(arr, {\n\t\tempty: {value: DOMARR.empty},\n\t\tclear: {value: DOMARR.clear},\n\t\tpop: {value: DOMARR.pop},\n\t\tpush: {value: DOMARR.push.bind(arr, info)},\n\t\tremove: {value: DOMARR.remove},\n\t\treverse: {value: DOMARR.reverse.bind(arr, info)},\n\t\tshift: {value: DOMARR.shift},\n\t\tsort: {value: DOMARR.sort.bind(arr, info)},\n\t\tsplice: {value: DOMARR.splice.bind(arr, info)},\n\t\tunshift: {value: DOMARR.unshift.bind(arr, info)}\n\t})\n\treturn arr\n}\n\nexport default defineArr\n","// import ARR from './array-helper.js'\nimport isInstance from './fast-instance-of.js'\nimport noop from './noop.js'\nimport {assign} from './polyfills.js'\nimport dbg from './debug.js'\nimport isBrowser from './is-browser.js'\nimport ARR from './array-helper.js'\nimport {queueDom, inform, exec} from '../render-queue.js'\nimport mountOptions from '../../mount-options.js'\n\nimport shared from './global-shared.js'\n\nconst EFMountPoint = '__ef_mount_point__'\n\nconst DOM = {}\n\nconst DocumentFragmentCache = []\nconst AnchorCache = []\n\nconst useFragment = (cb) => {\n\tconst fragment = DocumentFragmentCache.pop() || DOM.document.createDocumentFragment()\n\tconst recycle = () => {\n\t\tDocumentFragmentCache.push(fragment)\n\t}\n\treturn cb(fragment, recycle)\n}\n\nconst useAnchor = (cb) => {\n\tconst anchor = AnchorCache.pop() || DOM.document.createTextNode('')\n\tconst recycle = () => {\n\t\tAnchorCache.push(anchor)\n\t}\n\treturn cb(anchor, recycle)\n}\n\nconst EFFragment = class {\n\tconstructor() {\n\t\tthis.$children = []\n\t\tthis.$safeZone = DOM.document.createDocumentFragment()\n\t}\n\n\tappend(...args) {\n\t\tDOM.append(this.$safeZone, ...args)\n\t\tARR.push(this.$children, ...args)\n\t}\n\n\tappendTo(node) {\n\t\tDOM.append(node, ...this.$children)\n\t}\n\n\taddBefore(node) {\n\t\tDOM.before(node, ...this.$children)\n\t}\n\n\tremoveChild(node) {\n\t\tDOM.remove(node)\n\t\tARR.remove(this.$children, node)\n\t}\n\n\tremove() {\n\t\tDOM.append(this.$safeZone, ...this.$children)\n\t}\n\n\tget firstElement() {\n\t\treturn this.$children[0] || null\n\t}\n}\n\nconst appendNode = (node, target) => {\n\tconst {element, placeholder} = node.$ctx.nodeInfo\n\tDOM.append(target, element, placeholder)\n}\n\nconst insertBeforeNode = (node, ref) => {\n\tconst {element, placeholder} = node.$ctx.nodeInfo\n\tDOM.before(ref, element, placeholder)\n}\n\nconst handleMountPoint = (element, target, ref) => {\n\tif (element.nodeType !== 3) return\n\n\tconst mountPoint = element[EFMountPoint]\n\tif (!mountPoint) return\n\n\tconst {node} = mountPoint\n\tif (!node) return\n\n\tinform()\n\tif (ref) {\n\t\tif (ARR.isArray(node)) {\n\t\t\tfor (let i of node) insertBeforeNode(i, ref)\n\t\t} else insertBeforeNode(node, ref)\n\t} else {\n\t\t// eslint-disable-next-line no-lonely-if\n\t\tif (ARR.isArray(node)) {\n\t\t\tfor (let i of node) appendNode(i, target)\n\t\t} else appendNode(node, target)\n\t}\n\texec()\n}\n\nconst appendToTarget = (target, nodes) => {\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (DOM.isNodeInstance(i)) {\n\t\t\ttarget.appendChild(i)\n\t\t\thandleMountPoint(i, target)\n\t\t} else if (isInstance(i, EFFragment)) {\n\t\t\ti.appendTo(target)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target})\n\t\t}\n\t}\n\texec()\n}\n\nconst addBeforeTarget = (target, nodes) => {\n\tconst parentNode = target.parentNode\n\tinform()\n\tfor (let i of nodes) {\n\t\tif (DOM.isNodeInstance(i)) {\n\t\t\tparentNode.insertBefore(i, target)\n\t\t\thandleMountPoint(i, parentNode, target)\n\t\t} else if (isInstance(i, EFFragment)) {\n\t\t\ti.addBefore(target)\n\t\t} else if (i instanceof shared.EFBaseComponent) {\n\t\t\ti.$mount({target, option: mountOptions.BEFORE})\n\t\t}\n\t}\n\texec()\n}\n\nDOM.isNodeInstance = (node) => {\n\tif (DOM.isNode) return DOM.isNode(node)\n\treturn !!(node && node.nodeType)\n}\n\nDOM.before = (anchorNode, ...nodes) => {\n\tconst parentNode = anchorNode.parentNode\n\tconst firstNode = nodes[0]\n\tif (\n\t\tnodes.length === 1 &&\n\t\tDOM.isNodeInstance(firstNode) &&\n\t\t// When the node is a text node, check if it's not a mount point anchor\n\t\t// eslint-disable-next-line multiline-ternary, no-ternary\n\t\t(firstNode.nodeType === 3 ? !firstNode[EFMountPoint] : true)\n\t) {\n\t\tparentNode.insertBefore(nodes[0], anchorNode)\n\t} else if (parentNode.nodeType === 11) {\n\t\taddBeforeTarget(anchorNode, nodes)\n\t} else {\n\t\tuseFragment((tempFragment, recycleFragment) => {\n\t\t\tinform()\n\t\t\tappendToTarget(tempFragment, nodes)\n\t\t\tuseAnchor((tempAnchor, recycleAnchor) => {\n\t\t\t\tparentNode.insertBefore(tempAnchor, anchorNode)\n\t\t\t\tqueueDom(() => {\n\t\t\t\t\tparentNode.insertBefore(tempFragment, tempAnchor)\n\t\t\t\t\tparentNode.removeChild(tempAnchor)\n\t\t\t\t\trecycleAnchor()\n\t\t\t\t\trecycleFragment()\n\t\t\t\t})\n\t\t\t})\n\t\t\texec()\n\t\t})\n\t}\n}\n\nDOM.after = (anchorNode, ...nodes) => {\n\tif (anchorNode.nextSibling) return DOM.before(anchorNode.nextSibling, ...nodes)\n\treturn DOM.append(anchorNode.parentNode, ...nodes)\n}\n\nDOM.append = (parentNode, ...nodes) => {\n\tif (DOM.isNodeInstance(parentNode)) {\n\t\tif (nodes.length === 1 && DOM.isNodeInstance(nodes[0])) {\n\t\t\tparentNode.appendChild(nodes[0])\n\t\t\thandleMountPoint(nodes[0], parentNode)\n\t\t} else if (parentNode.nodeType === 11) {\n\t\t\tappendToTarget(parentNode, nodes)\n\t\t} else if (parentNode.nodeType === 1 || parentNode.nodeType === 9) {\n\t\t\tuseFragment((tempFragment, recycleFragment) => {\n\t\t\t\tinform()\n\t\t\t\tappendToTarget(tempFragment, nodes)\n\t\t\t\tuseAnchor((tempAnchor, recycleAnchor) => {\n\t\t\t\t\tparentNode.appendChild(tempAnchor)\n\t\t\t\t\tqueueDom(() => {\n\t\t\t\t\t\tparentNode.insertBefore(tempFragment, tempAnchor)\n\t\t\t\t\t\tparentNode.removeChild(tempAnchor)\n\t\t\t\t\t\trecycleAnchor()\n\t\t\t\t\t\trecycleFragment()\n\t\t\t\t\t})\n\t\t\t\t})\n\t\t\t\texec()\n\t\t\t})\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Handle EFComponent\n\tif (parentNode instanceof shared.EFBaseComponent) {\n\t\tif (!(ARR.isArray(parentNode.children))) {\n\t\t\tif (process.env.NODE_ENV !== 'production') dbg.warn(parentNode, 'has no `children` list mount point! Child nodes are all ignored!')\n\t\t\treturn\n\t\t}\n\n\t\tparentNode.children.push(...nodes)\n\n\t\treturn\n\t}\n\n\t// Handle fragment\n\t// if (isInstance(parentNode, EFFragment)) parentNode.append(...nodes)\n\tparentNode.append(...nodes)\n}\n\nDOM.remove = (node) => {\n\tif (DOM.isNodeInstance(node)) {\n\t\tif (node.parentNode) node.parentNode.removeChild(node)\n\t} else if (node instanceof shared.EFBaseComponent) node.$umount()\n\telse if (isInstance(node, EFFragment)) node.remove()\n}\n\nconst setDOMImpl = (impl) => {\n\tassign(DOM, impl)\n\n\tconst dummyText = DOM.document.createTextNode('')\n\n\tDOM.textNodeSupportsEvent = !!dummyText.addEventListener\n\tDOM.passiveSupported = false\n\tDOM.onceSupported = false\n\n\ttry {\n\t\tconst options = Object.create({}, {\n\t\t\tpassive: {\n\t\t\t\tget: () => {\n\t\t\t\t\tDOM.passiveSupported = true\n\t\t\t\t\treturn DOM.passiveSupported\n\t\t\t\t}\n\t\t\t},\n\t\t\tonce: {\n\t\t\t\tget: () => {\n\t\t\t\t\tDOM.onceSupported = true\n\t\t\t\t\treturn DOM.onceSupported\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\tDOM.document.addEventListener('__ef_event_option_test__', noop, options)\n\t\tDOM.document.removeEventListener('__ef_event_option_test__', noop, options)\n\t} catch (e) {\n\n\t\t/* do nothing */\n\t}\n}\n\nif (isBrowser) setDOMImpl({document, Node})\n\nexport {DOM, EFFragment, EFMountPoint, setDOMImpl, useFragment, useAnchor}\n","import {DOM} from './dom-helper.js'\n\n/**\n * @typedef {{bubbles: boolean, cancelable: boolean, composed: boolean}} EFEventOptions\n */\n\n/* Get new events that works in all target browsers\n * though a little bit old-fashioned\n */\nconst getEvent = (name, options = {}) => {\n\tconst event = DOM.document.createEvent && DOM.document.createEvent('CustomEvent') || new Event(name, options)\n\tif (event.initEvent) event.initEvent(name, options.bubbles, options.cancelable, options)\n\treturn event\n}\n\nexport default getEvent\n","const isInstance = (er, ee) => er.constructor === ee\n\nexport default isInstance\n","const shared = {}\n\nexport default shared\n","import dbg from './debug.js'\n\nconst isBrowser = typeof document !== 'undefined' && typeof Node !== 'undefined'\n\nif (process.env.NODE_ENV !== 'production') {\n\tif (isBrowser) dbg.info('Running in browser mode.')\n\telse dbg.info('Running in non-browser mode, please be sure to set a DOM simulation using `setDOMImpl`. See https://github.com/TheNeuronProject/ef.js#server-side-rendering for detail.')\n}\n\nexport default isBrowser\n","/* eslint-disable no-self-compare */\nconst isnan = obj => obj !== obj\n\nexport default isnan\n","const namespaces = {\n\txml: 'http://www.w3.org/XML/1998/namespace',\n\thtml: 'http://www.w3.org/1999/xhtml',\n\tsvg: 'http://www.w3.org/2000/svg',\n\tmath: 'http://www.w3.org/1998/Math/MathML',\n\txlink: 'http://www.w3.org/1999/xlink'\n}\n\n/**\n * Get declared namespaceURI using it's prefix\n * @param {string} prefix - Perfix for the namespaceURI\n * @returns {string} NamespaceURI defined by the prefix\n */\nconst getNamespace = (prefix) => {\n\tif (namespaces[prefix]) return namespaces[prefix]\n\n\tthrow new Error(`[EF] Namespace \"${prefix}\" has not been declared.`)\n}\n\n/**\n * Declare namespaceURI with a prefix\n * @param {string} prefix - Perfix for the namespaceURI\n * @param {string} namespaceURI - NamespaceURI associated with the prefix\n * @returns {void}\n */\nconst declareNamespace = (prefix, namespaceURI) => {\n\tif (namespaces[prefix]) {\n\t\tthrow new Error(`[EF] Namespace \"${prefix}\" has already been declared as \"${namespaces[prefix]}\".`)\n\t}\n\n\tnamespaces[prefix] = namespaceURI\n}\n\nexport {getNamespace, declareNamespace}\n","// eslint-disable-next-line no-empty-function\nexport default () => {}\n","// Enough for ef's usage, so no need for a full polyfill\nconst legacyAssign = (ee, ...ers) => {\n\tfor (let er of ers) {\n\t\tfor (let i in er) {\n\t\t\tee[i] = er[i]\n\t\t}\n\t}\n\n\treturn ee\n}\n\nconst assign = Object.assign || legacyAssign\n\nexport {assign, legacyAssign}\n","import {assign} from './polyfills.js'\n\n/**\n * @typedef {import('../renderer.js').EFBaseClass} EFBaseClass\n * @typedef {import('../renderer.js').EFTemplateScope} EFTemplateScope\n */\n\n/**\n * Attach a default scope to the component class\n * @template {component} T\n * @param {EFBaseClass} component - Component class to be scoped\n * @param {EFTemplateScope} initScope - Scope to be bond on the component class\n * @returns {T} - Scoped component class\n */\nconst scoped = (component, initScope) => class Scoped extends component {\n\tstatic __defaultScope() {\n\t\tconst prev = super.__defaultScope()\n\t\treturn assign(prev, initScope)\n\t}\n}\n\nexport default scoped\n","const createCache = (cb) => {\n\tconst cache = {}\n\treturn input => cache[input] || (cache[input] = cb(input))\n}\n\nconst hasColon = createCache(str => str.indexOf(':') >= 0)\n\nconst splitByColon = createCache(str => str.split(':'))\n\nconst isSVGEscape = createCache(tagName => ['foreignobject', 'desc', 'title'].indexOf(tagName.toLowerCase()) > -1)\n\nexport { createCache, hasColon, splitByColon, isSVGEscape }\n","import ARR from\t'./array-helper.js'\n\nconst typeOf = (obj) => {\n\tif (ARR.isArray(obj)) return 'array'\n\treturn typeof obj\n}\n\nexport default typeOf\n","/**\n * @typedef {string} EFMountOption\n * @typedef {{BEFORE: EFMountOption, AFTER: EFMountOption, APPEND: EFMountOption, REPLACE: EFMountOption}} EFMountConfig\n */\n\n/**\n * @type {EFMountConfig}\n */\nconst mountOptions = {\n\tBEFORE: 'before',\n\tAFTER: 'after',\n\tAPPEND: 'append',\n\tREPLACE: 'replace'\n}\n\nexport default mountOptions\n","import { create } from 'ef-core';\nexport default class Textbox extends create([{t:'div',a:{class:'container'}},[{t:'div',a:{class:'textbox'}},[{t:'div',a:{class:'text'}},[{t:'h1'},'This is the title'],[{t:'br'}],'This is the text']]]) {\n};\n","// extracted by mini-css-extract-plugin\nexport {};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import textbox from \"@src/textbox.eft\";\r\nimport \"@src/textbox.css\";\r\n\r\n(new textbox()).$mount({target: document.body});\r\n// for (let [key, value] of Object.entries(sidebarlist)) {\r\n//   const sidebarsubtoggle = new Sidebarsubtoggle({\r\n//     $data: {\r\n//       itemName: key,\r\n//       href: value.link.href,\r\n//     },\r\n//   });\r\n//   let array = [];\r\n//   value.item.forEach(function (element) {\r\n//     array.push(\r\n//       new Sidebaritem({\r\n//         $data: {\r\n//           itemName: element.itemName,\r\n//           href: element.href,\r\n//         },\r\n//       })\r\n//     );\r\n//   });\r\n//   sidebarsubtoggle[\"list\"] = array;\r\n//   sidebarsubtoggle.$mount({\r\n//     target: document.querySelector(\".sidebar-itembox> ul:first-of-type\"),\r\n//     option: {\r\n//       append: true,\r\n//     },\r\n//   });\r\n// }"],"names":[],"sourceRoot":""}